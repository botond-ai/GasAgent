
# Fail-safe response mechanism prompt-ban
Implement√°lt v√©delmi mechanizmusok:
1. Generation Node Fail-Safe (agent.py)
5 kritikus v√©delem:
CRITICAL FAIL-SAFE INSTRUCTIONS:
1. Only use information from retrieved documents - NO hallucination
2. If contradictory/unclear/missing ‚Üí explicit acknowledgment:
   "Sajn√°lom, nem tudok pontos v√°laszt adni..."
3. Empty context ‚Üí clear communication:
   "Sajn√°lom, nem tal√°ltam relev√°ns inform√°ci√≥t..."
4. Never fabricate: emails, phones, section IDs, policies, dates
5. When uncertain ‚Üí acknowledge + suggest contacting team

Magyar sablon v√°laszok:

‚ùå Ellentmond√°sos info: "Sajn√°lom, az el√©rhet≈ë dokumentumok nem tartalmaznak elegend≈ë inform√°ci√≥t..."
‚ùå √úres context: "Sajn√°lom, nem tal√°ltam relev√°ns inform√°ci√≥t ehhez a k√©rd√©shez..."
‚ö†Ô∏è Bizonytalan: "...k√©rlek, vedd fel a kapcsolatot a [domain] csapattal"
2. Truncated Prompt Fail-Safe (agent.py)
Token limit t√∫ll√©p√©s eset√©n (100k+ tokens):
CRITICAL FAIL-SAFE INSTRUCTIONS:
- Only use information from retrieved documents - NO hallucination
- If missing/unclear ‚Üí "Sajn√°lom, nem tudok pontos v√°laszt adni..."
- Never fabricate details not in documents

3. Memory Update Fail-Safe (agent.py)
Mem√≥ria extrakci√≥n√°l:
IMPORTANT: Only extract facts explicitly stated in conversation.
Do NOT invent, assume, or hallucinate information not present.
If no clear facts/decisions ‚Üí return empty lists.

V√©delem szintjei:
Komponens	Fail-Safe T√≠pus	V√©delem
Generation	5-pontos explicit instruction	Hallucin√°ci√≥, fabrication, empty context
Truncated Gen	3-pontos critical instruction	Token limit eset√©n is v√©delem
Memory Update	Strict extraction rule	Csak explicit facts, no assumption
Pydantic Models	Automatic validation	Type safety, field constraints
Guardrail Node	Validation retry loop	Section ID check, hallucination detection
üéØ Hallucin√°ci√≥ megel≈ëz√©s stackje:
User Query
    ‚Üì
Intent Detection (structured output, validated)
    ‚Üì
RAG Retrieval (actual documents)
    ‚Üì
Generation Prompt ‚Üí FAIL-SAFE INSTRUCTIONS (5 rules)
    ‚Üì
Pydantic Validation (RAGGenerationOutput)
    ‚Üì
Guardrail Node (validation errors check)
    ‚Üì (retry if errors)
Final Answer ‚Üí Validated, Grounded, No Hallucination

# Tool Executor Loop ‚úÖ
Sikeresen implement√°ltuk a Tool Executor Loop-ot a k√∂vetkez≈ë funkci√≥kkal:

1. ToolResult Pydantic modell ‚úÖ
tool_name, status (success/error/timeout), result, error, latency_ms, retry_count mez≈ëk
Automatikus valid√°ci√≥ Pydantic-kal
Warning-ok ha status √©s error/result mez≈ëk nem konzisztensek

2. Iterat√≠v Tool Executor Loop ‚úÖ
Sorban v√©grehajtja a kiv√°lasztott toolokat
asyncio.to_thread() haszn√°lat√°val szinkron registry.execute() async wrapper-ben
10 m√°sodperces timeout minden toolra (asyncio.wait_for)
Non-blocking: hib√°k nem √°ll√≠tj√°k meg a folyamatot, hanem ToolResult-ba ker√ºlnek
Latency m√©r√©s minden toolra
Success/error/timeout state tracking

3. Timeout + Error Handling ‚úÖ
10s timeout per tool
asyncio.TimeoutError kezel√©s ‚Üí status="timeout"
Registry szint≈± error handling (execute met√≥dus)
Agent szint≈± timeout wrapper
R√©szletes logging minden l√©p√©sn√©l

4. Tool Registry Integration - Agent haszn√°lja a registry-t tool v√©grehajt√°sra
6 √°tfog√≥ teszt - Success, timeout, error, multiple tools, mixed scenarios

# Felt√©teles routing
rag_only ‚Üí retrieval
tools_only ‚Üí tool_executor
rag_and_tools ‚Üí tool_executor

**Graph friss√≠t√©s (11 node):**
- tool_executor ‚Üí observation ‚Üí generation √©l
- retrieval ‚Üí observation ‚Üí generation √©l
- Observation node minimal v1: tool_results_count + retrieval_count tracking

# Implement√°lt v√°ltoz√°sok:

**backend/domain/llm_outputs.py:**
- ‚úÖ ToolResult modell hozz√°adva
  - field_validator status konzisztencia ellen≈ërz√©sre

**backend/services/agent.py:**
- ‚úÖ asyncio import
- ‚úÖ ToolResult import
- ‚úÖ _tool_executor_node teljes √°t√≠r√°sa (iterat√≠v, timeout, error handling)
- ‚úÖ _observation_node hozz√°adva (minimal v1)
- ‚úÖ Tool registry integration (dependency injection)
- ‚úÖ Graph routing: tool_executor/retrieval ‚Üí observation ‚Üí generation

**backend/infrastructure/tool_registry.py:**
- ‚úÖ ToolRegistry.default() factory 4 mock tool-lal
- ‚úÖ execute() met√≥dus error wrapping

**backend/tests/test_tool_executor.py:**
- ‚úÖ 6 r√©szletes teszt (success, timeout, error, multiple, mixed)

**backend/tests/test_observation.py:**
- ‚úÖ Observation count tracking teszt

**backend/tests/test_tool_registry.py:**
- ‚úÖ Registry alapm≈±veletek tesztje

**Teszt eredm√©ny:** 27/27 passed ‚úÖ

# K√∂vetkez≈ë Sprint: Sprint 5 - Observation Node b≈ëv√≠t√©s ‚úÖ
**K√âSZ!**

## Observation Node LLM-based Evaluation ‚úÖ

1. **ObservationOutput modell b≈ëv√≠t√©s:**
   - `sufficient`: bool - el√©g inform√°ci√≥nk van?
   - `next_action`: "generate" | "replan" - mi a k√∂vetkez≈ë l√©p√©s?
   - `gaps`: List[str] - hi√°nyz√≥ inform√°ci√≥k (max 5)
   - `reasoning`: str - indokl√°s (10-500 char)
   - `tool_results_count`, `retrieval_count` - metrik√°k
   - **Validators:**
     - gaps limit (max 5)
     - action konzisztencia (sufficient ‚Üî next_action)

2. **LLM-based observation evaluation:**
   - Tool results √∂sszegz√©s (success/error/timeout)
   - Retrieval summary
   - LLM prompt: "Do we have enough info?" ‚Üí ObservationOutput
   - `llm.with_structured_output(ObservationOutput)`
   - Fallback safe defaults ha LLM fail

3. **Replan Loop mechanizmus:**
   - `_observation_decision()` routing: replan vs generate
   - `replan_count` tracking (max 2 replan)
   - `observation ‚Üí {replan: plan_node, generate: generation}`
   - replan_count inicializ√°l√°s intent_detection-ben
   - Max 2 replan ut√°n force generate (safety)

4. **Graph friss√≠t√©s (11 node + replan loop):**
   ```
   intent ‚Üí plan ‚Üí select_tools ‚Üí {rag_only: retrieval, tools_only: executor, ...}
                      ‚Üì
   tool_executor ‚Üí observation ‚Üí _observation_decision ‚Üí {replan: plan_node ‚Ü∫, generate: generation}
   retrieval ‚Üí observation ‚Üí ...
   ```

5. **Tesztek (6 teszt, mind z√∂ld):**
   - Basic count tracking (backward compat)
   - Sufficient ‚Üí generate routing
   - Insufficient ‚Üí replan routing
   - Max replan limit (2) enforcement
   - Gap detection (multiple gaps)
   - LLM error fallback (safe defaults)

**Teszt eredm√©ny:** 32/32 passed ‚úÖ

**Graph state:**
- 11 nodes total
- Replan loop active (max 2 iterations)
- Observation ‚Üí replan/generate conditional routing

# K√∂vetkez≈ë: Integration Sprint
- End-to-end tesztek
- Replan loop integration teszt
- Multi-tool scenario tesztek
- Error handling edge cases

# ===========================================================================
# ========== UNIT Tesztek el√©r√©se
# ===========================================================================

backend\tests