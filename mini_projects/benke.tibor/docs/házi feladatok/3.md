Az API hÃ­vÃ¡sok mÃ¡r teljes mÃ©rtÃ©kben LangGraph alapÃºak.

## LangGraph alapÃº mÅ±kÃ¶dÃ©s:
ğŸ”„ Mi tÃ¶rtÃ©nik amikor IT domain query Ã©rkezik:
POST /api/query/ â†’ LangGraph StateGraph workflow indÃ­tÃ¡sa

7 node vÃ©grehajtÃ³dik:

intent_detection â†’ domain = "it"
retrieval â†’ Qdrant RAG (IT-KB dokumentumok)
generation â†’ GPT-4o-mini vÃ¡lasz citÃ¡ciÃ³kkal
guardrail â†’ ValidÃ¡lÃ¡s (IT-KB-XXX formÃ¡tum ellenÅ‘rzÃ©s)
collect_metrics â†’ Telemetria
execute_workflow ğŸ‘ˆ Itt kÃ©szÃ¼l a Jira ticket draft
memory_update â†’ Session mentÃ©s
Workflow node (6. node) elÅ‘kÃ©szÃ­ti a Jira ticket adatokat:

Frontend megkapja a workflow adatot â†’ a felhasznÃ¡lÃ³ igen-t vÃ¡lasztja â†’ POST /api/jira/ticket/ â†’ TÃ©nyleges Jira API hÃ­vÃ¡s

âœ… MiÃ©rt kÃ©t lÃ©pÃ©s (draft + creation)?
Design dÃ¶ntÃ©s:

ğŸ¯ User control: MegnÃ©zheti a draft-ot lÃ©trehozÃ¡s elÅ‘tt
ğŸ”’ No side-effects: LangGraph workflow idempotens (Ãºjra futtathatÃ³)
ğŸ›¡ï¸ Error handling: Jira API failure nem befolyÃ¡solja a query vÃ¡laszt
ğŸ“ Audit: KÃ¼lÃ¶n log entry a ticket creation-rÅ‘l
# RÃ©szletes vizuÃ¡lis flow diagram Ã©s magyarÃ¡zat: LANGGRAPH_API_FLOW.md 

## Pydentic validÃ¡ciÃ³
1. IntentOutput integrÃ¡ciÃ³ (agent.py)
âŒ ElÅ‘tte: response.content.strip().lower() manual parsing
âœ… UtÃ¡na: llm.with_structured_output(IntentOutput) - automatikus validÃ¡ciÃ³
ElÅ‘nyÃ¶k:
Confidence Ã©rtÃ©ket kerekÃ­ti 3 tizedesre
Figyelmeztet ha confidence < 0.5
Reasoning mezÅ‘ 10-500 karakter hosszÃºsÃ¡g validÃ¡ciÃ³
2. RAGGenerationOutput integrÃ¡ciÃ³ (agent.py)
âŒ ElÅ‘tte: response.content egyszerÅ± string
âœ… UtÃ¡na: llm.with_structured_output(RAGGenerationOutput) - strukturÃ¡lt kimenet
ElÅ‘nyÃ¶k:
Answer minimum 10 karakter
Language default "hu" ha nem adott
Section_ids validÃ¡ciÃ³ regex pattern ^[A-Z]+-KB-\d+$
Automatikus Ã¶sszekapcsolÃ¡s az extrahÃ¡lt section_ids-ekkel
3. MemoryUpdate integrÃ¡ciÃ³ (agent.py)
âŒ ElÅ‘tte: KÃ©t kÃ¼lÃ¶n LLM hÃ­vÃ¡s (summary + facts), manual parsing, duplikÃ¡ciÃ³ check
âœ… UtÃ¡na: Egy llm.with_structured_output(MemoryUpdate) hÃ­vÃ¡s
ElÅ‘nyÃ¶k:
model_validator biztosÃ­tja, hogy legalÃ¡bb 1 tartalomtÃ­pus (summary/facts/decisions) lÃ©tezik
Automatikus facts deduplikÃ¡ciÃ³ (egyedi listÃ¡k)
EgyszerÅ±bb kÃ³d, kevesebb hibalehetÅ‘sÃ©g
4. TurnMetrics integrÃ¡ciÃ³ (agent.py)
âŒ ElÅ‘tte: Manual dict construction
âœ… UtÃ¡na: TurnMetrics(...) Pydantic modell
ElÅ‘nyÃ¶k:
llm_latency_ms > 30000 esetÃ©n warning log
Datetime automatikus JSON encoding (ISO 8601 format)
Type safety minden metric mezÅ‘re
ValidÃ¡lt output a JSONL logging szÃ¡mÃ¡ra

## HibakezelÃ©sek
# HTTP status codes LangGraph Ã¡llapot alapjÃ¡n 
 HTTP Status Code pÃ©ldÃ¡k:
Scenario	HTTP Code	Processing Status	Success Flag
âœ… Clean pipeline	200 OK	SUCCESS	true
âš ï¸ Guardrail retry â†’ success	206 Partial Content	PARTIAL_SUCCESS	true
âŒ RAG timeout/failure	503 Service Unavailable	RAG_UNAVAILABLE	false
âŒ LLM generation error	500 Internal Server Error	GENERATION_FAILED	false
âŒ Max validation retries	422 Unprocessable Entity	VALIDATION_FAILED	false

# timeout kezelÃ©s + fallback + retry + state tracking
OPENAI_TIMEOUT = int(os.getenv('OPENAI_TIMEOUT', 30))  # seconds
OPENAI_MAX_RETRIES = int(os.getenv('OPENAI_MAX_RETRIES', 3))
RAG_TIMEOUT = int(os.getenv('RAG_TIMEOUT', 10))  # seconds

Async Timeout Wrapper (error_handling.py)
KezelÃ©si logika:
âœ… asyncio.TimeoutError â†’ Exponential backoff retry (1s, 2s, 4s...)
âœ… RateLimitError, APIConnectionError, APIError â†’ Retry with backoff
âœ… Max retries elÃ©rÃ©se â†’ TimeoutError vagy APICallError exception
ğŸ“Š Logging minden attempt-nÃ©l

RAG Timeout Integration (agent.py)
Timeout stratÃ©gia:
Komponens	Timeout	Max Retries	Exponential Backoff	Fallback
RAG (Qdrant)	10s	3	1s â†’ 2s â†’ 4s	Empty citations + rag_unavailable flag
LLM (OpenAI)	30s	3	1s â†’ 2s â†’ 4s	(kÃ¶vetkezÅ‘ feladat)
Memory Update	30s	3	1s â†’ 2s â†’ 4s	Non-blocking error

ğŸ”„ Retry logika:
Attempt 1 (timeout: 10s)
   â†“ TIMEOUT
Wait 1.0s
   â†“
Attempt 2 (timeout: 10s)
   â†“ TIMEOUT
Wait 2.0s
   â†“
Attempt 3 (timeout: 10s)
   â†“ TIMEOUT
Raise TimeoutError â†’ RAG unavailable â†’ Summary-only mode

State tracking:
RAG unavailable esetÃ©n:
state["rag_unavailable"] = True  # Flag beÃ¡llÃ­tÃ¡s
processing_status = ProcessingStatus.RAG_UNAVAILABLE  # HTTP 503

# DegradÃ¡ciÃ³: RAG unavailable â†’ summary-only mode
Graceful Degradation implementÃ¡lva:
1. RAG unavailable detection (agent.py)
2. Generation node fallback check (agent.py)
Summary-only response generator (agent.py)
Ãšj metÃ³dus: _generate_summary_only_response()

AdatforrÃ¡sok:
âœ… memory_summary - KorÃ¡bbi beszÃ©lgetÃ©s Ã¶sszefoglalÃ¡sa
âœ… memory_facts - ExtrahÃ¡lt tÃ©nyek (max 5)
âœ… messages[-5:] - UtolsÃ³ 5 Ã¼zenet conversation context

Prompt instrukciÃ³k:
1. Answer ONLY based on conversation summary and known facts
2. DO NOT make up or hallucinate information
3. Acknowledge limitation: "âš ï¸ VÃ¡lasz korlÃ¡tozott informÃ¡ciÃ³k alapjÃ¡n..."
4. If cannot answer â†’ suggest trying later or contacting team
5. Keep response concise and factual

Ultimate fallback (ha LLM is fail):
"âš ï¸ VÃ¡lasz korlÃ¡tozott informÃ¡ciÃ³k alapjÃ¡n (dokumentum retrieval Ã¡tmenetileg nem elÃ©rhetÅ‘):
SajnÃ¡lom, jelenleg nem tudok rÃ©szletes vÃ¡laszt adni, mert a dokumentum-keresÃ©si 
rendszer Ã¡tmenetileg nem elÃ©rhetÅ‘. KÃ©rlek, prÃ³bÃ¡ld Ãºjra kÃ©sÅ‘bb..."

Degradation stack:
graph TD
    A[User Query] --> B[Intent Detection]
    B --> C[RAG Retrieval + Timeout Wrapper]
    C -->|Success| D[Normal Generation with Citations]
    C -->|Timeout/Error| E[state rag_unavailable = True]
    E --> F[Summary-Only Generation]
    F --> G[Memory Summary + Facts + Last 5 Messages]
    G --> H[Warning Message + Limited Answer]
    H --> I[HTTP 503 Service Unavailable]

Degradation szintek:
Szint	AdatforrÃ¡s	Citations	HTTP Status	User Notification
Normal	RAG + Memory	âœ… Yes	200 OK	-
Summary-Only	Memory + Context	âŒ No	503 Service Unavailable	âš ï¸ "VÃ¡lasz korlÃ¡tozott informÃ¡ciÃ³k alapjÃ¡n..."
Ultimate Fallback	Hardcoded message	âŒ No	503	âš ï¸ "PrÃ³bÃ¡ld Ãºjra kÃ©sÅ‘bb..."

âœ… ElÅ‘nyÃ¶k:
Non-blocking: RAG failure esetÃ©n sem failel az egÃ©sz pipeline
Transparent: User-nek jelezzÃ¼k a korlÃ¡tozÃ¡st
Context-aware: Conversation history alapjÃ¡n mÃ©g mindig tud vÃ¡laszolni
Monitored: rag_unavailable flag + HTTP 503 status code
Fail-safe: Ultimate fallback ha mÃ©g az LLM is failel

ğŸ“ PÃ©lda vÃ¡lasz RAG unavailable esetÃ©n:
âš ï¸ VÃ¡lasz korlÃ¡tozott informÃ¡ciÃ³k alapjÃ¡n (dokumentum retrieval Ã¡tmenetileg nem elÃ©rhetÅ‘):
Az elÅ‘zÅ‘ beszÃ©lgetÃ©sÃ¼nk alapjÃ¡n emlÃ©kszem, hogy szabadsÃ¡grÃ³l kÃ©rdeztÃ©l. 
Sajnos most nem tudom ellenÅ‘rizni a pontos szabadsÃ¡g-politikÃ¡t a HR dokumentumokban.
Javaslom:
- PrÃ³bÃ¡ld Ãºjra 5-10 perc mÃºlva
- Vedd fel kÃ¶zvetlenÃ¼l a kapcsolatot a HR csapattal
- EllenÅ‘rizd a belsÅ‘ HR portÃ¡lt

# idempotencia
ProblÃ©ma:
Ugyanaz a request tÃ¶bbszÃ¶r elkÃ¼ldve â†’ tÃ¶bbszÃ¶ri LLM hÃ­vÃ¡s, kÃ¶ltsÃ©g, duplikÃ¡lt vÃ¡laszok
Feedback endpoint-ban mÃ¡r volt ON CONFLICT megoldÃ¡s
/api/regenerate/ endpoint mÃ¡r hasznÃ¡l cache-t, nem Ã¼tkÃ¶zhet

MegoldÃ¡s:
X-Request-ID header alapÃº cache (Redis, TTL: 5 perc)
Client kÃ¼ldi az X-Request-ID header-t (UUID v4)
Backend ellenÅ‘rzi Redis cache-ben: request_id:{id}
Ha HIT â†’ cached response vissza (X-Cache-Hit: true header)
Ha MISS â†’ normÃ¡l feldolgozÃ¡s, majd response cache-elÃ©se

ElÅ‘nyÃ¶k:
âœ… Idempotens: Ugyanaz a request_id â†’ ugyanaz a vÃ¡lasz
âœ… KÃ¶ltsÃ©gcsÃ¶kkentÃ©s: DuplikÃ¡lt requestek nem hÃ­vnak LLM-et
âœ… Gyors vÃ¡lasz: Cache hit esetÃ©n < 10ms latency
âœ… Kompatibilis: Nem Ã¼tkÃ¶zik a /api/regenerate/ endpoint-tal (mÃ¡s cache kulcs)

# Memory Reducer Pattern + Szemantikus TÃ¶mÃ¶rÃ­tÃ©s
ProblÃ©ma:
Eddig: Overwrite mode - Minden 8 Ã¼zenet utÃ¡n NEW summary (korÃ¡bbi elveszik)
HosszÃº beszÃ©lgetÃ©seknÃ©l az elsÅ‘ N turn informÃ¡ciÃ³ elvÃ©sz
Nincs semantikus szÅ±rÃ©s â†’ irrelevÃ¡ns facts felhalmozÃ³dnak

MegoldÃ¡s - Reducer Pattern:
Previous Summary + New Messages â†’ LLM Merge â†’ Updated Summary
                                            â†“
                                   Semantic Compression
                                            â†“
                            Keep 8 MOST RELEVANT facts

Szemantikus TÃ¶mÃ¶rÃ­tÃ©s (LLM-based filtering):
Merge similar facts: "user wants X" + "user needs X" â†’ "user requires X"
Prioritize recent over old (conflict resolution)
Keep domain constraints (dates, names, numbers)
Drop irrelevant facts (conversation direction changed)
Max 8 facts (compressed from prev_facts + new_messages)

Multi-level Summarization (jÃ¶vÅ‘beli extension):
Short (8 msg) â†’ medium (50 msg) â†’ long (200+ msg)
Tracked: total_msg_count vÃ¡ltozÃ³
graph LR
    A[8 messages] --> B{Need Summary?}
    B -->|Yes| C[Load prev_summary + prev_facts]
    C --> D[LLM: Merge + Compress]
    D --> E[New Summary 3-5 sent]
    D --> F[8 MOST RELEVANT facts]
    E --> G[state.memory_summary = merged]
    F --> G

# idempontencia Ã©s memory reducer Ã¶sszefoglalÃ³
ElÅ‘nyÃ¶k:
âœ… KumulatÃ­v emlÃ©kezet: KorÃ¡bbi summary-k NEM vesznek el
âœ… Szemantikus filter: LLM dÃ¶nti el mi relevÃ¡ns (nem fizikai limit)
âœ… Merge conflicts: Recent facts felÃ¼lÃ­rjÃ¡k old-okat
âœ… Scalable: Long conversations â†’ multi-level summarization (later extension)
âœ… KÃ¶ltsÃ©ghatÃ©kony: Max 8 fact tÃ¡rolÃ¡sa (nem 100+ fact)

Logging:
Memory updated (REDUCER): 6 facts (compressed from 13 items), 
summary length: 342 chars, total messages: 24

Idempotencia:
âœ… Ugyanaz a X-Request-ID â†’ instant cached response (<10ms)
âœ… KÃ¼lÃ¶nbÃ¶zÅ‘ X-Request-ID â†’ Ãºj LLM hÃ­vÃ¡s
âœ… Nincs X-Request-ID â†’ normÃ¡l mÅ±kÃ¶dÃ©s (backward compatible)
âœ… Response header tartalmazza: X-Cache-Hit: true (cache HIT esetÃ©n)
Memory Reducer:

âœ… TÃ¶bb turn conversation â†’ summary Ã¶sszefÅ±zÅ‘dik (nem overwrite)
âœ… Fact limit: Max 8 fact tÃ¡rolva (nem tÃ¶bb)
âœ… Conflict resolution: Ãšjabb fact felÃ¼lÃ­rja rÃ©gebbi-t (pl. budget 50k â†’ 60k)
âœ… Log output: "Memory updated (REDUCER): X facts (compressed from Y items)"

# ===========================================================================
# ========== UNIT Tesztek elÃ©rÃ©se
# ===========================================================================

backend\tests